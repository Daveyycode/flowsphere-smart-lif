/**
 * FlowSphere Certificate Templates
 *
 * Fake certificate headers that make encrypted vault files look like
 * legitimate system files when opened outside FlowSphere.
 *
 * When a family member or someone else tries to open these files:
 * - iOS: "This certificate cannot be verified" or "Invalid certificate"
 * - Android: "Cannot open file" or "Unknown credential format"
 *
 * The headers are designed to:
 * 1. Be recognized as certificate/credential file types
 * 2. Fail validation gracefully (not crash, just "invalid")
 * 3. Look like legitimate system files in file managers
 *
 * @author FlowSphere Team
 * @version 1.0.0
 */

// ============================================
// APPLE CERTIFICATE HEADER (512 bytes)
// ============================================

/**
 * Fake Apple Certificate Header
 *
 * Mimics the structure of an Apple X.509 certificate (.cert/.cer/.pem)
 * When opened on iOS/macOS:
 * - Shows as "Certificate" in Files app
 * - Trying to install: "This certificate is not valid"
 * - Cannot be parsed by Keychain (our encrypted data follows)
 *
 * Structure: DER-encoded X.509 with invalid signature
 */
export const APPLE_CERT_HEADER = new Uint8Array([
  // ASN.1 SEQUENCE tag for certificate
  0x30, 0x82, 0x01, 0xFB,

  // TBSCertificate SEQUENCE
  0x30, 0x82, 0x01, 0x64,

  // Version [0] EXPLICIT
  0xA0, 0x03, 0x02, 0x01, 0x02,

  // Serial Number
  0x02, 0x10,
  0x46, 0x4C, 0x4F, 0x57, 0x53, 0x50, 0x48, 0x45,  // "FLOWSPHE"
  0x52, 0x45, 0x56, 0x41, 0x55, 0x4C, 0x54, 0x31,  // "REVAULT1"

  // Signature Algorithm (SHA-256 with RSA)
  0x30, 0x0D,
  0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B,
  0x05, 0x00,

  // Issuer (Apple-like)
  0x30, 0x5A,
  // Country: US
  0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
  // State: California
  0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A,
  0x43, 0x61, 0x6C, 0x69, 0x66, 0x6F, 0x72, 0x6E, 0x69, 0x61,
  // Organization: Apple Inc.
  0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x09,
  0x41, 0x70, 0x70, 0x6C, 0x65, 0x20, 0x49, 0x6E, 0x63,
  // Common Name: Apple Root CA
  0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x13,
  0x41, 0x70, 0x70, 0x6C, 0x65, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
  0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x33,

  // Validity (dates that make it "expired")
  0x30, 0x1E,
  // Not Before: 2020-01-01
  0x17, 0x0D, 0x32, 0x30, 0x30, 0x31, 0x30, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A,
  // Not After: 2020-12-31 (expired)
  0x17, 0x0D, 0x32, 0x30, 0x31, 0x32, 0x33, 0x31, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A,

  // Subject (same as issuer for self-signed look)
  0x30, 0x5A,
  0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53,
  0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A,
  0x43, 0x61, 0x6C, 0x69, 0x66, 0x6F, 0x72, 0x6E, 0x69, 0x61,
  0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x09,
  0x41, 0x70, 0x70, 0x6C, 0x65, 0x20, 0x49, 0x6E, 0x63,
  0x31, 0x1C, 0x30, 0x1A, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x13,
  0x41, 0x70, 0x70, 0x6C, 0x65, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20,
  0x43, 0x41, 0x20, 0x2D, 0x20, 0x47, 0x33,

  // Subject Public Key Info (placeholder - invalid key)
  0x30, 0x59,
  // Algorithm: EC public key
  0x30, 0x13,
  0x06, 0x07, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01,
  0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07,
  // Public key (garbage that looks like a key)
  0x03, 0x42, 0x00, 0x04,
  0x46, 0x4C, 0x4F, 0x57, 0x53, 0x50, 0x48, 0x45,  // FLOWSPHE
  0x52, 0x45, 0x53, 0x45, 0x43, 0x55, 0x52, 0x45,  // RESECURE
  0x56, 0x41, 0x55, 0x4C, 0x54, 0x53, 0x59, 0x53,  // VAULTSYS
  0x54, 0x45, 0x4D, 0x32, 0x30, 0x32, 0x35, 0x00,  // TEM2025
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  // Signature Algorithm
  0x30, 0x0D,
  0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x0B,
  0x05, 0x00,

  // Signature Value (invalid - will fail verification)
  0x03, 0x81, 0x81, 0x00,
  // 128 bytes of "signature" (FlowSphere marker hidden in signature)
  0x46, 0x4C, 0x4F, 0x57, 0x53, 0x50, 0x48, 0x45,  // FLOWSPHE
  0x52, 0x45, 0x48, 0x49, 0x44, 0x44, 0x45, 0x4E,  // REHIDDEN
  0x56, 0x41, 0x55, 0x4C, 0x54, 0x46, 0x49, 0x4C,  // VAULTFIL
  0x45, 0x53, 0x59, 0x53, 0x54, 0x45, 0x4D, 0x00,  // ESYSTEM

  // Padding to reach 512 bytes
  ...new Array(512 - 350).fill(0x00)
])

// ============================================
// ANDROID CREDENTIAL HEADER (512 bytes)
// ============================================

/**
 * Fake Android Credential Header
 *
 * Mimics the structure of an Android Keystore file (.credential/.keystore)
 * When opened on Android:
 * - Shows as "Credential" in file manager
 * - Trying to import: "Invalid credential format"
 * - Cannot be parsed by Android Keystore
 *
 * Structure: PKCS#12-like header with invalid content
 */
export const ANDROID_CREDENTIAL_HEADER = new Uint8Array([
  // PKCS#12 magic number
  0x30, 0x82, 0x01, 0xFB,

  // Version
  0x02, 0x01, 0x03,

  // AuthSafe (ContentInfo)
  0x30, 0x82, 0x01, 0xA0,

  // Content Type: data
  0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01,

  // Content [0] EXPLICIT
  0xA0, 0x82, 0x01, 0x8F,
  0x04, 0x82, 0x01, 0x8B,

  // SafeContents SEQUENCE
  0x30, 0x82, 0x01, 0x87,

  // SafeBag for private key
  0x30, 0x82, 0x00, 0xC0,

  // Bag Type: keyBag
  0x06, 0x0B, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x0C, 0x0A, 0x01, 0x01,

  // Bag Value [0] EXPLICIT
  0xA0, 0x82, 0x00, 0xAD,

  // PrivateKeyInfo
  0x30, 0x82, 0x00, 0xA9,

  // Version
  0x02, 0x01, 0x00,

  // Algorithm (RSA)
  0x30, 0x0D,
  0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01,
  0x05, 0x00,

  // Private Key (garbage data with FlowSphere marker)
  0x04, 0x82, 0x00, 0x93,

  // FlowSphere identification bytes (hidden in "key data")
  0x41, 0x4E, 0x44, 0x52, 0x4F, 0x49, 0x44, 0x5F,  // ANDROID_
  0x46, 0x4C, 0x4F, 0x57, 0x53, 0x50, 0x48, 0x45,  // FLOWSPHE
  0x52, 0x45, 0x5F, 0x56, 0x41, 0x55, 0x4C, 0x54,  // RE_VAULT
  0x5F, 0x53, 0x45, 0x43, 0x55, 0x52, 0x45, 0x5F,  // _SECURE_
  0x53, 0x54, 0x4F, 0x52, 0x41, 0x47, 0x45, 0x5F,  // STORAGE_
  0x56, 0x31, 0x2E, 0x30, 0x2E, 0x30, 0x00, 0x00,  // V1.0.0

  // More fake key data
  0x30, 0x82, 0x00, 0x59,
  0x02, 0x01, 0x00,
  0x02, 0x41,
  0x00, 0xC4, 0x3D, 0x7B, 0x00, 0x01, 0x02, 0x03,
  0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
  0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
  0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
  0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23,
  0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B,
  0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
  0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,

  // Bag Attributes
  0x31, 0x2A,
  // Friendly Name
  0x30, 0x28,
  0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x14,
  0x31, 0x1B,
  0x1E, 0x19,
  // "Android Keychain" in UTF-16
  0x00, 0x41, 0x00, 0x6E, 0x00, 0x64, 0x00, 0x72,
  0x00, 0x6F, 0x00, 0x69, 0x00, 0x64, 0x00, 0x20,
  0x00, 0x4B, 0x00, 0x65, 0x00, 0x79,

  // MacData (for integrity - will fail)
  0x30, 0x31,
  // MAC
  0x30, 0x21,
  0x30, 0x09,
  0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A,
  0x05, 0x00,
  0x04, 0x14,
  // SHA-1 of nothing (invalid)
  0xDA, 0x39, 0xA3, 0xEE, 0x5E, 0x6B, 0x4B, 0x0D,
  0x32, 0x55, 0xBF, 0xEF, 0x95, 0x60, 0x18, 0x90,
  0xAF, 0xD8, 0x07, 0x09,

  // Salt
  0x04, 0x08,
  0x46, 0x53, 0x56, 0x41, 0x55, 0x4C, 0x54, 0x00,  // FSVAULT

  // Iterations
  0x02, 0x02, 0x08, 0x00,

  // Padding to reach 512 bytes
  ...new Array(512 - 280).fill(0x00)
])

// ============================================
// HEADER IDENTIFICATION
// ============================================

/**
 * Check if data starts with Apple certificate header
 */
export function isAppleCertHeader(data: Uint8Array): boolean {
  if (data.length < 4) return false
  // Check for ASN.1 SEQUENCE with our length
  return data[0] === 0x30 && data[1] === 0x82 && data[2] === 0x01 && data[3] === 0xFB
}

/**
 * Check if data starts with Android credential header
 */
export function isAndroidCredHeader(data: Uint8Array): boolean {
  if (data.length < 4) return false
  // Check for PKCS#12 magic
  return data[0] === 0x30 && data[1] === 0x82 && data[2] === 0x01 && data[3] === 0xFB
}

/**
 * Get header length for a disguise type
 */
export function getHeaderLength(disguiseType: 'apple' | 'android'): number {
  return disguiseType === 'apple'
    ? APPLE_CERT_HEADER.length
    : ANDROID_CREDENTIAL_HEADER.length
}

// ============================================
// ERROR MESSAGES (What users see outside FlowSphere)
// ============================================

/**
 * These are the expected error messages when someone tries to open
 * the disguised files outside of FlowSphere:
 *
 * iOS (Files app → Quick Look):
 * - "This certificate cannot be verified"
 * - "Certificate is not valid"
 * - "Unable to install profile"
 *
 * iOS (Settings → Install Profile):
 * - "Profile Failed to Install"
 * - "The profile 'Apple Root CA - G3' is not signed"
 *
 * Android (File Manager):
 * - "Cannot open file"
 * - "No app can open this file"
 *
 * Android (Settings → Security → Install from storage):
 * - "Invalid credential format"
 * - "Failed to install credentials"
 *
 * macOS (Keychain Access):
 * - "The contents of this certificate cannot be verified"
 *
 * Windows (Certificate Manager):
 * - "The certificate is not valid"
 * - "An error occurred during certificate validation"
 */

export default {
  APPLE_CERT_HEADER,
  ANDROID_CREDENTIAL_HEADER,
  isAppleCertHeader,
  isAndroidCredHeader,
  getHeaderLength
}
